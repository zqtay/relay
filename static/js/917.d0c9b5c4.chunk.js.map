{"version":3,"file":"static/js/917.d0c9b5c4.chunk.js","mappings":"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","sources":["game/Game.js","game/GameConst.js"],"sourcesContent":["import { Buffer } from \"buffer\";\r\nimport fullDict from \"./dict.json\";\r\nimport {\r\n    MAGIC_SUCCESS,\r\n    MAGIC_FAILED,\r\n    MIN_WORD_LENGTH,\r\n    MAX_WORD_LENGTH,\r\n    MIN_OVERLAP_LENGTH,\r\n    MAX_OVERLAP_LENGTH,\r\n    MIN_STEPS,\r\n    MAX_STEPS,\r\n    MODE_DEFAULT,\r\n    MODE_EMPTY\r\n} from \"./GameConst\";\r\n\r\nconst GEN_PUZZLE_TIMEOUT = 2000; // in ms\r\n\r\nclass Game {\r\n    mode;\r\n    solution;\r\n    keys;\r\n    dict;\r\n    hints;\r\n\r\n    constructor() {\r\n        this.mode = MODE_EMPTY;\r\n        this.hints = [];\r\n    }\r\n\r\n    genPuzzle(settings = { mode: null, solution: null }) {\r\n        if (settings.mode == null) {\r\n            this.mode = MODE_DEFAULT;\r\n        }\r\n        else {\r\n            // Check game settings limit\r\n            if (!(settings.mode.wordLen >= MIN_WORD_LENGTH && settings.mode.wordLen <= MAX_WORD_LENGTH) ||\r\n                !(settings.mode.overlapLen >= MIN_OVERLAP_LENGTH && settings.mode.overlapLen <= MAX_OVERLAP_LENGTH) ||\r\n                !(settings.mode.noOfWords >= MIN_STEPS && settings.mode.noOfWords <= MAX_STEPS)) {\r\n                return this.result(MAGIC_FAILED, \"Invalid mode\");\r\n            }\r\n\r\n            if ((settings.mode.wordLen >> 1) < settings.mode.overlapLen) {\r\n                return this.result(MAGIC_FAILED, \"Invalid mode\");\r\n            }\r\n\r\n            this.mode = { ...settings.mode };\r\n        }\r\n\r\n        if (settings.solution == null) {\r\n            // Get dict for this puzzle settings\r\n            this.dict = fullDict[this.mode.wordLen];\r\n            // Create empty solution array with correct length\r\n            this.solution = Array(this.mode.noOfWords).fill('');\r\n            let filteredDict = null;\r\n            let deadEnd = [];\r\n\r\n            // Manual timeout break\r\n            let elapsedTime = 0;\r\n            const startTime = Date.now();\r\n\r\n            // Recursive loop\r\n            let i = 0;\r\n            while (i < this.mode.noOfWords) {\r\n                if (i === 0) {\r\n                    this.solution[i] = this.getRandomItem(this.dict);\r\n                    i++;\r\n                }\r\n                else {\r\n                    // Get the ending of the previous word\r\n                    let prevEnd = this.solution[i - 1].slice(-this.mode.overlapLen);\r\n                    // Get the list of words starting with the ending of the previous word\r\n                    // and excluding those that were identified to lead to dead end\r\n                    // and excluding duplicates \r\n                    filteredDict = this.dict.filter(e => e.startsWith(prevEnd))\r\n                        .filter(e => !deadEnd.includes(e))\r\n                        .filter(e => !this.solution.includes(e));\r\n                    if (filteredDict.length > 0) {\r\n                        // Get random word from the filtered list\r\n                        this.solution[i] = this.getRandomItem(filteredDict);\r\n                        // Next word\r\n                        i++;\r\n                    }\r\n                    else {\r\n                        // Previous word leads to dead end\r\n                        // Add previous word to dead end list\r\n                        deadEnd.push(this.solution[i - 1]);\r\n                        // Go back to previous word to generate a new word\r\n                        this.solution[i - 1] = \"\";\r\n                        i--;\r\n                    }\r\n                }\r\n                if (deadEnd.length === this.dict.length) {\r\n                    return this.result(MAGIC_FAILED, \"No solution found\");\r\n                }\r\n                elapsedTime = Date.now() - startTime;\r\n                if (elapsedTime > GEN_PUZZLE_TIMEOUT) {\r\n                    return this.result(MAGIC_FAILED, \"No solution found\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Get from settings\r\n            this.solution = [...settings.solution];\r\n            this.dict = fullDict[this.mode.wordLen];\r\n        }\r\n        // Available character keys to solve puzzle\r\n        this.keys = this.solution.join('').slice(this.mode.overlapLen, -this.mode.overlapLen);\r\n        this.keys = [...new Set(this.keys.split(''))].sort();\r\n        // Create hints array with filled spaces\r\n        this.hints = Array(this.mode.noOfWords).fill(' '.repeat(this.mode.wordLen));\r\n        // Start word\r\n        this.hints[0] = this.solution[0].slice(0, this.mode.overlapLen) + ' '.repeat(this.mode.wordLen - this.mode.overlapLen);\r\n        // End word\r\n        this.hints[this.mode.noOfWords - 1] = ' '.repeat(this.mode.wordLen - this.mode.overlapLen) + this.solution.at(-1).slice(-this.mode.overlapLen);\r\n\r\n        return this.result(MAGIC_SUCCESS, {\r\n            hints: [...this.hints],\r\n            inputs: [...this.hints]\r\n        });\r\n    }\r\n\r\n    async genPuzzleAsync(settings = { mode: null, solution: null }) {\r\n        return new Promise(resolve => {\r\n            resolve(this.genPuzzle(settings));\r\n        });\r\n    }\r\n\r\n    genPuzzleFromEncoded(encoded) {\r\n        let res = this.getSettingsFromEncoded(encoded);\r\n        if (res.status !== MAGIC_SUCCESS) {\r\n            return res;\r\n        }\r\n        else {\r\n            return this.genPuzzle(res.data);\r\n        }\r\n    }\r\n\r\n    validateInput(index, input) {\r\n        input = input.toLowerCase();\r\n        // console.log(`${input} ${input.length} ${this.mode.wordLen}`);\r\n        // Check input length\r\n        if (input.length !== this.mode.wordLen) {\r\n            return this.result(MAGIC_FAILED, \"Wrong length\");\r\n        }\r\n\r\n        // Check blanks\r\n        if (input.includes(\" \")) {\r\n            return this.result(MAGIC_FAILED, \"Missing chars\");\r\n        }\r\n\r\n        // Check given hints\r\n        let hint = this.hints[index];\r\n        for (let i = 0; i < this.mode.wordLen; i++) {\r\n            if (hint[i] !== \" \" && input[i] !== hint[i]) {\r\n                return this.result(MAGIC_FAILED, \"Word not match\");\r\n            }\r\n        }\r\n\r\n        // Check input with given chars\r\n        let invalidChar = \"\";\r\n        input.split(\"\").forEach((a, i) => {\r\n            if (hint[i] === a) {\r\n                // Skip checking if same as hint\r\n                return;\r\n            }\r\n            if (!this.keys.includes(a)) {\r\n                // Return the invalid char\r\n                if (!invalidChar.includes(a)) {\r\n                    invalidChar += a;\r\n                }\r\n            }\r\n        });\r\n        if (invalidChar !== \"\") {\r\n            return this.result(MAGIC_FAILED, \"Invalid characters: \" + invalidChar);\r\n        }\r\n\r\n        // Check the word in dictionary\r\n        if (!this.dict.includes(input)) {\r\n            return this.result(MAGIC_FAILED, \"Not in dict\");\r\n        }\r\n\r\n        return this.result(MAGIC_SUCCESS, \"Valid input\");\r\n    }\r\n\r\n    validateAll(inputs) {\r\n        // Sanity check\r\n        if (inputs.length !== this.mode.noOfWords) {\r\n            return this.result(MAGIC_FAILED, \"Wrong length\");\r\n        }\r\n\r\n        // Check for blanks\r\n        if (inputs.some((input) => input.includes(\" \"))) {\r\n            return this.result(MAGIC_FAILED, \"Missing words\");\r\n        }\r\n\r\n        for (const [index, input] of inputs.entries()) {\r\n            // Check for duplicates\r\n            if (inputs.filter(e => input === e).length > 1) {\r\n                return this.result(MAGIC_FAILED, `Duplicate words: ${input}`);\r\n            }\r\n            // Check each input\r\n            if (this.validateInput(index, input).status !== MAGIC_SUCCESS) {\r\n                return this.result(MAGIC_FAILED, `Invalid word: ${input}`);\r\n            }\r\n            if (index >= 1) {\r\n                // Check current input's beginning is the same as \r\n                // previous input's ending\r\n                if (!input.startsWith(inputs[index - 1].slice(-this.mode.overlapLen))) {\r\n                    return this.result(MAGIC_FAILED, `Word not match: ${inputs[index - 1]}, ${input}`);\r\n                }\r\n            }\r\n        }\r\n        return this.result(MAGIC_SUCCESS, \"Puzzle solved\");\r\n    }\r\n\r\n    addHint(wordIndex = null, charIndex = null) {\r\n        if (wordIndex === null || wordIndex < 0 || wordIndex >= this.mode.noOfWords) {\r\n            return this.result(MAGIC_FAILED, \"Invalid word index\");\r\n        }\r\n        let hints = [];\r\n        let data = null;\r\n        const hint = this.hints[wordIndex];\r\n        if (charIndex === null) {\r\n            // Get random hint\r\n            this.solution[wordIndex].split(\"\").forEach(\r\n                (a, i) => {\r\n                    if (hint[i] === \" \") {\r\n                        hints.push({ index: i, hint: a });\r\n                    }\r\n                }\r\n            );\r\n\r\n            if (hints.length === 0) {\r\n                return this.result(MAGIC_FAILED, \"No available hints\");\r\n            }\r\n\r\n            data =  this.getRandomItem(hints);\r\n        }\r\n        else {\r\n            if (charIndex < 0 || charIndex >= this.mode.wordLen) {\r\n                this.result(MAGIC_FAILED, \"Invalid char index\");\r\n            }\r\n            data = {index: charIndex, hint: this.solution[wordIndex][charIndex]};\r\n        }\r\n        this.hints[wordIndex] = hint.slice(0, data.index) + data.hint + hint.slice(data.index + 1);\r\n        return this.result(MAGIC_SUCCESS, data);\r\n    }\r\n\r\n    /** Public getters **/\r\n    getMode() {\r\n        return this.result(MAGIC_SUCCESS, this.mode);\r\n    }\r\n\r\n    getHints() {\r\n        return this.result(MAGIC_SUCCESS, this.hints)\r\n    }\r\n\r\n    getKeys() {\r\n        return this.result(MAGIC_SUCCESS, this.keys)\r\n    }\r\n\r\n    getSolution() {\r\n        return this.result(MAGIC_SUCCESS, this.solution)\r\n    }\r\n\r\n    /** URL query and game settings **/\r\n    // Generate encoded query from settings\r\n    getEncodedFromSettings() {\r\n        if (this.mode === null || this.solution === null) {\r\n            return this.result(MAGIC_FAILED, \"Game settings not initialized\");\r\n        }\r\n        let solStr = \"\";\r\n        const overlap = this.mode.overlapLen;\r\n        try {\r\n            for (const [index, word] of this.solution.entries()) {\r\n                if (index === 0) {\r\n                    solStr += word;\r\n                }\r\n                else {\r\n                    solStr += word.slice(overlap);\r\n                }\r\n            }\r\n            let encoded = `${this.mode.wordLen},${this.mode.overlapLen},${this.mode.noOfWords},${Buffer.from(solStr).toString(\"base64\")}`;\r\n            return this.result(MAGIC_SUCCESS, encoded);\r\n        }\r\n        catch (e) {\r\n            this.result(MAGIC_FAILED, \"Failed to generate encoded string\");\r\n        }\r\n    }\r\n\r\n    // Parse encoded query to settings\r\n    getSettingsFromEncoded(encoded) {\r\n        let settings = { mode: { wordLen: -1, overlapLen: -1, noOfWords: -1 }, solution: [] };\r\n        try {\r\n            let textArray = encoded.split(\",\");\r\n            // Mode\r\n            settings.mode.wordLen = parseInt(textArray[0]);\r\n            settings.mode.overlapLen = parseInt(textArray[1]);\r\n            settings.mode.noOfWords = parseInt(textArray[2]);\r\n            // Solution\r\n            let solStr = Buffer.from(textArray[3], \"base64\").toString(\"ascii\");\r\n            let startIndex, endIndex = 0;\r\n            for (let i = 0; i < settings.mode.noOfWords; i++) {\r\n                if (i === 0) {\r\n                    settings.solution.push(solStr.slice(0, settings.mode.wordLen));\r\n                }\r\n                else {\r\n                    startIndex = i * (settings.mode.wordLen - settings.mode.overlapLen);\r\n                    endIndex = startIndex + settings.mode.wordLen;\r\n                    settings.solution.push(solStr.slice(startIndex, endIndex));\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            return this.result(MAGIC_FAILED, \"Invalid format\");\r\n        }\r\n        return this.result(MAGIC_SUCCESS, settings);\r\n    }\r\n\r\n    /** Utils **/\r\n    // Return result object\r\n    result(status, data = \"\") {\r\n        return { status: status, data: data };\r\n    }\r\n\r\n    // Get random item from an array\r\n    getRandomItem(array) {\r\n        return array[Math.floor(Math.random() * array.length)];\r\n    }\r\n}\r\n\r\nconst CurrentGame = new Game();\r\n\r\nexport {\r\n    Game,\r\n    CurrentGame\r\n};\r\n","// Return values\r\nexport const MAGIC_SUCCESS = 0xAABB;\r\nexport const MAGIC_FAILED = 0xBBAA;\r\n\r\n// Default game settings\r\nexport const WORD_LENGTH_DEFAULT = 5;\r\nexport const OVERLAP_LENGTH_DEFAULT = 2;\r\nexport const MAX_STEPS_DEFAULT = 5;\r\n\r\n// Custom game settings limit\r\nexport const MIN_WORD_LENGTH = 5;\r\nexport const MAX_WORD_LENGTH = 7;\r\nexport const MIN_OVERLAP_LENGTH = 1;\r\nexport const MAX_OVERLAP_LENGTH = 3;\r\nexport const MIN_STEPS = 3;\r\nexport const MAX_STEPS = 8;\r\n\r\nexport const MODE_DEFAULT = {\r\n    wordLen: WORD_LENGTH_DEFAULT,\r\n    overlapLen: OVERLAP_LENGTH_DEFAULT,\r\n    noOfWords: MAX_STEPS_DEFAULT\r\n};\r\n\r\nexport const MODE_EMPTY = {\r\n    wordLen: 0,\r\n    overlapLen: 0,\r\n    noOfWords: 0\r\n};\r\n\r\nexport const STATE_EMPTY = {\r\n    inputs: [],\r\n    hints: []\r\n};"],"names":["Game","this","mode","MODE_EMPTY","hints","settings","solution","MODE_DEFAULT","wordLen","MIN_WORD_LENGTH","MAX_WORD_LENGTH","overlapLen","MIN_OVERLAP_LENGTH","MAX_OVERLAP_LENGTH","noOfWords","MIN_STEPS","MAX_STEPS","result","MAGIC_FAILED","dict","fullDict","Array","fill","filteredDict","deadEnd","startTime","Date","now","i","getRandomItem","prevEnd","slice","filter","e","startsWith","includes","length","push","keys","join","Set","split","sort","repeat","at","MAGIC_SUCCESS","inputs","Promise","resolve","genPuzzle","encoded","res","getSettingsFromEncoded","status","data","index","input","toLowerCase","hint","invalidChar","forEach","a","some","entries","validateInput","wordIndex","charIndex","solStr","overlap","word","Buffer","toString","textArray","parseInt","startIndex","endIndex","array","Math","floor","random","CurrentGame","STATE_EMPTY"],"sourceRoot":""}